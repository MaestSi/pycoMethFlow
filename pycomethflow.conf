params {
    // Path to the tsv sample sheet file
    samples = "/path/to/samples.txt"
 
    // Path to a folder where to store results
    results_dir = "/path/to/results_dir"

    // Path to the fasta reference
    reference = "/path/to/file.fasta"

    // Path to a gtf file
    gtf = "/path/to/file.gff"
    
    // pycoMeth parameters
    Meth_Seg_m = 10
    Meth_Seg_w = 300
    Meth_Seg_print_diff_met = ""
    //Meth_Seg_print_diff_met = "--print_diff_met"
    CGI_Finder_m = 0
    CGI_Finder_w = 200
    CGI_Finder_c = 0.5
    CGI_Finder_r = 0.6
    Meth_Comp_m = 12 
    Meth_Comp_l = 1
    Meth_Comp_pvalue_adj_method = "fdr_bh"
    Meth_Comp_pvalue_threshold = 0.01
    //Meth_Comp_only_tested_sites = "--only_tested_sites"
    Meth_Comp_only_tested_sites = ""
    Comp_Report_n = 100
    Comp_Report_d = 100000
    Comp_Report_pvalue_threshold = 0.01
    Comp_Report_min_diff_llr = 1
    Comp_Report_n_len_bin = 500
    Comp_Report_export_static_plots = ""
    //Comp_Report_export_static_plots = "--export_static_plots" 
    //Comp_Report_report_non_significant = "False"
    Comp_Report_report_non_significant = "--report_non_significant"

    help = false

    // Flags to select which process to run
    alignment = true
    indexing = true
    nanopolish = true
    pycomethMethSeg = true
    pycomethMethComp = true
    pycomethCompReport = true
}

profiles {
	singularity {
	    singularity.enabled = true
	    singularity.autoMounts = false
	    //singularity.cacheDir = "/path/to/singularity/cacheDir" // if commented, work dir is going to be used
	    process {
	    cpus = 1
	    executor = 'pbspro' // set to 'local' if you are not using a queue management system
	    queue = 'workq'
	    perJobMemLimit = true
	    queueStatInterval = '1 ms'
	    pollInterval = '1 ms'
	    container = 'maestsi/pycomethflow2:latest'
	    containerOptions = '--bind /home:/home' // adjust according to which directory you wish to make accessible to singularity

	    withName:alignment {
	    	cpus = { params.alignment ? 1 : 1 }
	    	memory = { params.alignment ? 30.GB + (5.GB * (task.attempt-1)) : 1.GB }
	    	errorStrategy = { task.exitStatus == 137 ? 'retry' : 'terminate' }
	    	maxRetries = 3
	    }
	    withName:indexing {
	    	cpus = { params.indexing ? 4 : 1 }
	    	memory = { params.indexing ? 4.GB + (5.GB * (task.attempt-1)) : 1.GB }
	    	errorStrategy = { task.exitStatus == 137 ? 'retry' : 'terminate' }
	    	maxRetries = 3
	    }
	    withName:nanopolish {
	    	cpus = { params.nanopolish ? 4 : 1 }
	    	memory = { params.nanopolish ? 30.GB + (5.GB * (task.attempt-1)) : 1.GB }
	    	errorStrategy = { task.exitStatus == 137 ? 'retry' : 'terminate' }
	    	maxRetries = 3
	    }
	    withName:pycomethMethSeg {
	    	cpus = { params.pycomethMethSeg ? 4 : 1 }
	    	memory = { params.pycomethMethSeg ? 30.GB + (5.GB * (task.attempt-1)) : 1.GB }
	    	errorStrategy = { task.exitStatus == 137 ? 'retry' : 'terminate' }
	    	maxRetries = 3
	    }
	    withName:pycomethMethComp{
	    	cpus = { params.pycomethMethComp ? 4 : 1 }
	    	memory = { params.pycomethMethComp ? 20.GB + (5.GB * (task.attempt-1)) : 1.GB }
	    	errorStrategy = { task.exitStatus == 137 ? 'retry' : 'terminate' }
	    	maxRetries = 3
	    }
	    withName:pycomethCompReport {
	    	cpus = { params.pycomethCompReport ? 4 : 1 }
	    	memory = { params.pycomethCompReport ? 20.GB + (5.GB * (task.attempt-1)) : 1.GB }
	    	errorStrategy = { task.exitStatus == 137 ? 'retry' : 'terminate' }
	    	maxRetries = 3
	    }
	}
    }
    docker {
	    docker.enabled = true
	    docker.autoMounts = false
	    //docker.cacheDir = "/path/to/docker/cacheDir" // if commented, work dir is going to be used
	    process {
	    cpus = 1
	    executor = 'local'
        container = 'maestsi/pycomethflow2:latest'
	    containerOptions = '-v /Users:/Users' // adjust according to which directory you wish to make accessible to docker
	    withName:alignment {
	    	cpus = { params.alignment ? 4 : 1 }
	    	memory = { params.alignment ? 4.GB + (5.GB * (task.attempt-1)) : 1.GB }
	    	errorStrategy = { task.exitStatus == 137 ? 'retry' : 'terminate' }
	    	maxRetries = 3
	    }
        withName:indexing {
	    	cpus = { params.indexing ? 4 : 1 }
	    	memory = { params.indexing ? 4.GB + (5.GB * (task.attempt-1)) : 1.GB }
	    	errorStrategy = { task.exitStatus == 137 ? 'retry' : 'terminate' }
	    	maxRetries = 3
	    }
	    withName:nanopolish {
	    	cpus = { params.nanopolish ? 1 : 1 }
	    	memory = { params.nanopolish ? 4.GB + (5.GB * (task.attempt-1)) : 1.GB }
	    	errorStrategy = { task.exitStatus == 137 ? 'retry' : 'terminate' }
	    	maxRetries = 3
	    }
	    withName:pycomethMethSeg {
	    	cpus = { params.pycomethMethSeg ? 1 : 1 }
	    	memory = { params.pycomethMethSeg ? 4.GB + (5.GB * (task.attempt-1)) : 1.GB }
	    	errorStrategy = { task.exitStatus == 137 ? 'retry' : 'terminate' }
	    	maxRetries = 3
	    }
	    withName:pycomethMethComp{
	    	cpus = { params.pycomethMethComp ? 1 : 1 }
	    	memory = { params.pycomethMethComp ? 4.GB + (5.GB * (task.attempt-1)) : 1.GB }
	    	errorStrategy = { task.exitStatus == 137 ? 'retry' : 'terminate' }
	    	maxRetries = 3
	    }
	    withName:pycomethCompReport {
	    	cpus = { params.pycomethCompReport ? 1 : 1 }
	    	memory = { params.pycomethCompReport ? 4.GB + (5.GB * (task.attempt-1)) : 1.GB }
	    	errorStrategy = { task.exitStatus == 137 ? 'retry' : 'terminate' }
	    	maxRetries = 3
	    }
        }
    }    
}

tower {
	enabled = false
	endpoint = '-'
	accessToken = 'insert access token'
}
